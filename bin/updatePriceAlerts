#!/usr/bin/env node

const axios = require('axios');
const CSConstants = require('../constants/CSConstants');
const mongoose = require('mongoose');
const PriceAlertModel = require('../models/PriceAlertModel');
const request = require('request');
const utils = require('../utils/utils');

const headers = {
  'Accept': CSConstants.mimeTypeJson,
};

const options = {
  url: CSConstants.googleSheetsApiUrl,
  headers: headers
};

mongoose.Promise = Promise;
mongoose.connect(
  CSConstants.mongoCSDatabase,
  {
    useNewUrlParser: true
  }
);

let alertDataObjects = [];
let successfullyCreated = 0;

Date.prototype.getUnixTime = function() { return this.getTime()/1000|0 };
if(!Date.now) Date.now = function() { return new Date(); }
Date.time = function() { return Date.now().getUnixTime(); }

/************************************
  TODO:
    - make reusable function logic
    - add types to function arguments
    - seperate logic when possible
************************************/

function addToDBCollection(symbol, startTime, historicalData, hoursOfDataStored, alertId) {
  PriceAlertModel.findOne({
    _id: {
        symbol: `${symbol}`,
        startTime,
    }
  }, (err, alert) => {
    if (alert) {
      console.log(symbol + startTime + CSConstants.alertExists);
      alert.btcPriceAtAlertTime = 0;
      alert.usdPriceAtAlertTime = 0;
      alert.save();
    } else {
      PriceAlertModel.create({
        _id: {
          symbol: `${symbol}`,
          startTime,
        },
        history: historicalData,
        hoursOfDataStored: hoursOfDataStored,
        symbol: symbol,
        startTime: startTime,
        storedDataApiUrl: null,
        alertId: alertId,
        btcPriceAtAlertTime: 0,
        usdPriceAtAlertTime: 0,
      }, (err, alert) => {
          if (err) {
            console.log(CSConstants.error, err);
          } else {
            successfullyCreated++;
            console.log(CSConstants.numOfRecordsSaved + successfullyCreated);
          }
      });
    }
  });
}

function updateDBCollection(symbol, startTime, historicalData, hoursOfDataStored, apiUrl) {
  let alertTimePriceBTC = historicalData['btc'][0].open;
  let alertTimePriceUSD = historicalData['usd'][0].open;
  let id = {
    symbol: `${symbol}`,
    startTime,
  };

  PriceAlertModel.update({ _id: id }, { $set: { history: historicalData, hoursOfDataStored: hoursOfDataStored, startTime: startTime, storedDataApiUrl: apiUrl, btcPriceAtAlertTime: alertTimePriceBTC, usdPriceAtAlertTime: alertTimePriceUSD}}, updateDBCallback);

  function updateDBCallback(err, numAffected) {
    if (err) {
      console.log(CSConstants.error + err);
    } else {
      console.log(CSConstants.numOfDocsAffected + numAffected + ' : ' + symbol);
    }
  }
}

function hasValidData(data) {
  return (data[0].high !== 0 && data[0].low !== 0 && data[0].open !== 0 && data[0].close !== 0);
}

function getHourlyHistoricalData(endTime, coinSymbol, limit, callback) {
  const symbol = coinSymbol.replace(/\s/g, '');
  const timeLimit = '&limit=' + limit;
  const ts = '&toTs=' + endTime;
  const historicalData = {};

  const usdConversionUrl =
    CSConstants.ccHourlyHistApi +
    symbol +
    CSConstants.ccUSDToSymbol +
    timeLimit +
    CSConstants.ccAggregate +
    ts;

  const btcConversionUrl =
    CSConstants.ccHourlyHistApi +
    symbol +
    CSConstants.ccBTCToSymbol +
    timeLimit +
    CSConstants.ccAggregate +
    ts;

  if (symbol === 'BTC') {
    axios.get(usdConversionUrl).then(res => {
      if (res.data.Data.length > 0) {
        historicalData['btc'] = res.data.Data;
        historicalData['usd'] = res.data.Data;
        console.log(CSConstants.validHistory + symbol);
      }
      callback(historicalData, usdConversionUrl);
    }).catch(function (error) {
      console.log(CSConstants.axiosError, error);
    });
  } else {
    axios.get(btcConversionUrl).then(btcResponse => {
      axios.get(usdConversionUrl).then(usdResponse => {
        let btcData = btcResponse.data.Data;
        let usdData = usdResponse.data.Data;

        if (btcData.length > 0 && usdData.length > 0) {
          if ((hasValidData(btcData)) && (hasValidData(usdData))) {
            historicalData['btc'] = btcData;
            historicalData['usd'] = usdData;
            console.log(CSConstants.validHistory + symbol);
          }
        }
        callback(historicalData, usdConversionUrl);
      }).catch(function (error) {
        console.log(CSConstants.axiosError, error);
      });
    }).catch(function (error) {
      console.log(CSConstants.axiosError, error);
    });
  }
}

function iterateAlertData(alertData, updateAlertData) {
  for (let i = 0; i < alertData.length; i++) {
    const coinSymbol = alertData[i][0];
    const currentAlertTimestamp = alertData[i][1];
    const currentAlertId = alertData[i][2];
    addToDBCollection(coinSymbol, currentAlertTimestamp, [], 0, currentAlertId);
  }
  updateAlertData();
}

function updateAlerts(alerts) {
  const twoSeconds = 2000;
  const alertsLength = alerts.length;
  let i = 0;

  function throttleIteration() {
    const coinSymbol = alerts[i]._id.symbol;
    const alertStartTime = alerts[i]._id.startTime;
    const {endTime, days} = utils.findClosestTimestampWithData(alertStartTime);
    const daysInHours = days * 24;

    getHourlyHistoricalData(endTime, coinSymbol, daysInHours, (data, apiURL) => {
      if (data.btc && data.usd) {
        updateDBCollection(coinSymbol, alertStartTime, data, daysInHours, apiURL);
      } else {
        console.log(CSConstants.dataEmpty + data + apiURL);
      }
    });
    i++;
    if (i < alertsLength) {
      setTimeout(throttleIteration, twoSeconds);
    }
  }
  throttleIteration();
  console.log(CSConstants.done);
}

function checkAlertDataAndUpdate() {
  setTimeout(throttleUpdate, 5000);
  function throttleUpdate() {
    //  {hoursOfDataStored: { $ne: 168 } },
    PriceAlertModel.find((err, alerts) => {
      if (err) {
        console.log(CSConstants.error, err);
      } else if (alerts.length > 0) {
        updateAlerts(alerts);
      }
    });
  }
}

function getLatestPriceAlertData(error, response, body) {
  if (!error && response.statusCode === 200) {
    const json = JSON.parse(body);

    for (let i = 1; i < json.values.length; i++) {
      const row = json.values[i];
      const symbol = row[0];
      const dateTime = row[1];
      const alertId = row[2];
      const startTime = new Date(dateTime).getUnixTime();
      alertDataObjects.push([symbol, startTime, alertId]);
    }
    console.log(CSConstants.numOfAlerts, alertDataObjects.length);
    iterateAlertData(alertDataObjects, checkAlertDataAndUpdate);
  } else {
    console.log(CSConstants.noInfoFound);
  }
}

request(options, getLatestPriceAlertData);
